= Firestore4k
:source-highlighter: highlightjs

// customer icons for GitHub
ifdef::env-github[]
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:important-caption: ‚ùóÔ∏è
:caution-caption: üî•
:warning-caption: ‚ö†Ô∏è
endif::[]

image:https://img.shields.io/github/workflow/status/vihangpatil/firestore4k/Build/main?logo=github[Build Status]
image:https://img.shields.io/badge/kotlin-1.6.21-blue.svg?logo=kotlin[Kotlin version badge]
image:https://img.shields.io/github/license/vihangpatil/firestore4k.svg[GitHub license]

Firestore Client for Kotlin JVM with strict (and relaxed) type-system. +
Inspired by https://kotlinlang.org/docs/whatsnew1420.html#extensions-for-java-nio-file-path[Kotlin Path API], where div `/` symbol is overloaded to express file path.

See project website at https://firestore4k.io[firestore4k.io] for detailed documentation & examples.

== Code preview
DSL to express Firestore collection & document path
[source,kotlin]
----
val users = rootCollection<User, UserId>("users")
val messages = users.subCollection<Message, MessageId>("messages")

// /users
users

// /users/user1
users / UserId("user1")

// /users/user1/message
users / UserId("user1") / messages

// /users/user1/message/message1
users / UserId("user1") / messages / MessageId("message1")
----

Use collection & document path for operations.
[source,kotlin]
----
// add (ID auto generated by Firestore)
val userId: String = add(users, User())
// set
put(users / UserId("user1"), User())
// get
val user = get<User>(users / UserId("user1"))
// get all
val messages = getAll<Message>(users / UserId("user1") / messages)
----
Define `flexible` **dynamic** or `strict + type-inference` **typed** _collection hierarchy_.
[source,kotlin]
----
// Using `dynamic` API
val users = collection("users")
val messages = collection("messages")
//       OR
// Using `typed` API
val users = rootCollection<User, UserId>("users")
val messages = users.subCollection<Message, MessageId>("messages")
----

== Preface

link:https://cloud.google.com/firestore/[GCP Firestore] client for link:https://kotlinlang.org/[Kotlin] + link:https://gradle.org/[Gradle] project.

*Firestore* is a NoSQL *document-store* (tree based) database-as-a-service from Google Cloud Platform.

API in *two flavors*:

* *Dynamic* -> Flexible dynamic API with relaxed type checks for DB schema. +
* *Typed* -> Typed-API with type safety for DB schema.

For *Typed* API, you can optionally use *annotations* along with *KSP* (Kotlin Symbol Processing) to autogenerate some boilerplate code.

== Sample code
Firestore stores the DB in alternate hierarchy of *collections* and *documents*. +
Ref: https://firebase.google.com/docs/firestore/manage-data/structure-data

This structure is a mirror of the *Resource Oriented Design* of _REST API Design guidelines_ recommended by Google. +
Ref: https://cloud.google.com/apis/design/resources

* Collections and documents are alternative in hierarchy: *<collection>/<document>/<collection>/<document>*
* Top-level is always a collection, not a document.
* Collection names as _plural_.


For the sample code, I will use a *root* (top-level) collection: *users* and its *sub* (child) collection: *messages*.

|===
| Path | Description

| _users_
| *users* as root collection

| _users_/*user1*
| *user1* document under *users* root collection

| _users_/*user1*/_messages_
| *messages* sub-collection under *user1* document

| _users_/*user1*/_messages_/*message1*
| *message1* document under *messages* sub-collection under *user1* document
|===

=== For _dynamic_ API
Define collections
[source,kotlin]
----
val users = collection("users")
val messages = collection("messages")
----
And then use them in PATHs of CRUD operations such as...
[source,kotlin]
----
// add (ID auto generated by Firestore)
val userId: String = add(users, User())
val messageId: String = add(users / "user1" / messages, Message())

// set
put(users / "user1", User())
put(users / "user1" / messages / "message1", Message())

// get
val user: User = get(users / "user1")
val message: Message = get(users / "user1" / messages / "message1")
// OR
val user = get<User>(users / "user1")
val message = get<Message>(users / "user1" / messages / "message1")

// get all
val users: Collection<User> = getAll(users)
val messages: Collection<Message> = getAll(users / "user1" / messages)
// OR
val users = getAll<User>(users)
val messages = getAll<Message>(users / "user1" / messages)

// delete
delete(users / "user1" / messages / "message1")
deleteAll(users / "user1" / messages)
delete(users / "user1")
deleteAll(users)
----

=== For typed API
Define collection hierarchy and type bindings
[source, kotlin]
----
val users = rootCollection<User>("users")
val messages = users.subCollection<User, Message>("messages")
----
CRUD operations for *typed* are similar to *dynamic*, but with type safety & inference.

* So, *users* have to be root collection and *messages* under it.
* _Code accepts User / Message objects only_ in their respective *add* and *put* functions.
* Type inference for return value of object & collection in *get* and *getAll* functions respectively.

[source,kotlin]
----
// add (ID auto generated by Firestore)
val userId: String = add(users, User())
val messageId: String = add(users / "user1" / messages, Message())

// set
put(users / UserId("user1"), User())
put(users / UserId("user1") / messages / MessageId("message1"), Message())

// get
val user = get(users / UserId("user1"))
val message = get(users / UserId("user1") / messages / MessageId("message1"))

// get all
val users = getAll(users)
val messages = getAll(users / UserId("user1") / messages)

// delete
deleteDocument(users / UserId("user1") / messages / MessageId("message1"))
deleteCollection(users / UserId("user1") / messages)
deleteDocument(users / UserId("user1"))
deleteCollection(users)
----

=== Using annotations + KSP for typed API

[WARNING]
====
Experimental
====


Collection hierarchy and type bindings are autogenerated using annotations. +
But for simple cases, it is not worth the complexity since it is more verbose.
[source, kotlin]
----
// root collection will not have @[ChildOf] annotation.
@Serializable
@Collection("users")
data class User(
    val name: String,
)

@IdOf("users")
@JvmInline
value class UserId(private val value: String) {
    override fun toString(): String = value
}

@Serializable
@Collection("messages")
@ChildOf("users")
data class Message(
    val body: String,
)

@IdOf("messages")
@JvmInline
value class MessageId(private val value: String) {
    override fun toString(): String = value
}

----

== Dependencies
Add repository URL https://s01.oss.sonatype.org/content/repositories/snapshots/ for SNAPSHOT versions.

=== For _dynamic_ API
[source, kotlin]
----
plugins {
    kotlin("jvm")
    kotlin("plugin.serialization")
}

dependencies {
    implementation("io.firestore4k:dynamic-api:$latestVersion")
}
----
=== For _typed_ API
[source, kotlin]
----
plugins {
    kotlin("jvm")
    kotlin("plugin.serialization")
}

dependencies {
    implementation("io.firestore4k:typed-api:$latestVersion")
}
----
=== For _typed_ API with _annotations_ & _KSP_

[WARNING]
====
Experimental
====

[source, kotlin]
----
plugins {
    kotlin("jvm")
    kotlin("plugin.serialization")
    id("com.google.devtools.ksp")
}

dependencies {
    implementation("io.firestore4k:typed-api:$latestVersion")
    compileOnly(project("io.firestore4k:annotations:$latestVersion"))
    ksp(project("io.firestore4k:ksp:$latestVersion"))
}

kotlin {
    sourceSets.main {
        kotlin.srcDir("build/generated/ksp/main/kotlin")
    }
    sourceSets.test {
        kotlin.srcDir("build/generated/ksp/test/kotlin")
    }
}
----
